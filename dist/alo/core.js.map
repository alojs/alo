{"version":3,"sources":["webpack://alo.[name]/webpack/universalModuleDefinition","webpack://alo.[name]/webpack/bootstrap","webpack://alo.[name]/./lib/alo/actionResolver/index.ts","webpack://alo.[name]/./lib/alo/actionResolver/batchActionResolverDecorator.ts","webpack://alo.[name]/./lib/alo/util/dispatchThunk.ts","webpack://alo.[name]/./lib/alo/util/isPlainObject.ts","webpack://alo.[name]/./lib/alo/main/observable.ts","webpack://alo.[name]/./lib/alo/store/index.ts","webpack://alo.[name]/./node_modules/fast-clone/index.js","webpack://alo.[name]/./lib/alo/actionNormalizer/batchActionNormalizerDecorator.ts","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/inherits.js","webpack://alo.[name]/./lib/alo/actionNormalizer/index.ts","webpack://alo.[name]/./lib/alo/mutator/index.ts","webpack://alo.[name]/./lib/alo/util/index.ts","webpack://alo.[name]/./lib/alo/util/dispatchBatch.ts","webpack://alo.[name]/./lib/alo/util/dispatchPromise.ts","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://alo.[name]/./lib/alo/actionNormalizer/undoableActionNormalizerDecorator.ts","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/createClass.js","webpack://alo.[name]/./lib/alo/main/core.ts","webpack://alo.[name]/(webpack)/buildin/module.js","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/typeof.js","webpack://alo.[name]/./lib/alo/undoable/index.ts","webpack://alo.[name]/./lib/alo/observable/index.ts","webpack://alo.[name]/./lib/alo/actionNormalizer/dateActionNormalizerDecorator.ts","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://alo.[name]/./lib/alo/action/index.ts","webpack://alo.[name]/./lib/alo/event/index.ts","webpack://alo.[name]/./lib/alo/util/dispatchActions.ts","webpack://alo.[name]/./lib/alo/subscribable/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ActionResolver","callSubscribersLazy","action","callSubscribers","applyMutator","setAction","event","createEvent","tagsSet","AbstractActionResolverDecorator","actionResolver","_actionResolver","options","resolve","BatchActionResolverDecorator","store","meta","batchItem","type","BATCH_ACTION_TYPE","batchId","rootBatchId","_eventByBatchId","newBatch","parentBatchIds","_observableBatchByBatchId","batchStart","payload","_childsByBatchId","parentId","push","batchEnd","typeThunk","thunk","dispatchThunk","dispatchedActions","result","getState","dispatch","dispatchedAction","isPromiseLike","then","toString","isPlainObject","obj","actionTypes","INIT","Store","mutator","state","actionNormalizer","ActionNormalizer","subscribable","Subscribable","cloneDeep","_cloneDeep","pureByDefault","observable","_observable","isAction","tmp","_actionNormalizer","normalize","callBack","_afterDispatchNormalization","console","error","_subscribable","_setAction","_callSubscribers","_applyMutator","pureAction","pure","_pureByDefault","originalPayload","_isMutating","Error","batch","_applyMutatorBatch","_action","_mutator","impure","listener","remember","subscribe","func","observe","pauseObserverFn","isInitAction","setWildCard","err","Function","clone","Date","setTime","getTime","RegExp","newRegExp","fixTypes","JSON","parse","stringify","fixPropertyValue","original","copy","originalValue","newValue","isNaN","NaN","Infinity","Array","index","length","getOwnPropertyNames","forEach","regexpText","String","slashIndex","lastIndexOf","slice","BatchActionNormalizerDecorator","batchItems","map","cloneAction","undo","reverse","storeProxy","childAction","dispatchBatch","ds","redo","AbstractActionNormalizerDecorator","setPrototypeOf","subClass","superClass","TypeError","constructor","writable","configurable","typeMutator","consumer","combineMutators","mutators","mutatorKeys","keys","propName","promise","undefined","once","fn","done","findInArray","values","predicate","idx","resolveBatchAction","batchIdx","batchAction","dispatchPromise","_getPrototypeOf","getPrototypeOf","__proto__","UndoableActionNormalizerDecorator","undoData","ReferenceError","_setPrototypeOf","_defineProperties","target","props","descriptor","Constructor","protoProps","staticProps","webpackPolyfill","deprecate","paths","children","_typeof","assertThisInitialized","iterator","setUndoData","getUndoData","setUndoableCache","undoableCache","createUndoThunk","id","createRedoThunk","createUndoableMutator","actionFilter","past","future","pastAction","pop","notify","log","do","futureAction","nextId","generateUniqueId","observerInfoMap","observableInfoMap","isObservable","resultObj","pauseObserver","pause","currentObserver","callObserver","observerId","previousId","previousPause","observerInfo","running","setValue","storage","observerIdSet","notifyObservers","notifyInBatches","targetObserverIdSets","idSet","removeProp","__observableId","propObserverIdSetMap","setProp","deep","isArray","itemKey","itemValue","set","observableId","plannedObserverCalls","nextPlanIdx","observerIds","planIdx","batchInfo","count","indexOf","getOriginObject","computationBatchIdx","computation","propsObj","objKeys","subscriptions","unsubscribed","unsubscribeFn","subscription","init","prevBatchId","empty","extract","DateActionNormalizerDecorator","date","instance","parentByTag","entityContainerByTag","childrenByTag","registerEntityContainer","containerTag","tag","createTag","entityContainer","setTagChildren","child","getTagEntity","entityId","initialize","container","containers","subject","tags","entity","setTag","parentTag","parentWildCardIsSet","childTag","tagIsSet","checkWildCard","wildCardIsSet","dispatchActions","actions","_currentListeners","_nextListeners","_separateNextListeners","isSubscribed","_subscribersCalled","_lastListenerOptions","splice","listenerOptions"],"mappings":"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","file":"core.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"core\"] = factory();\n\telse\n\t\troot[\"alo\"] = root[\"alo\"] || {}, root[\"alo\"][\"core\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"XGAS\");\n","import { Action } from \"../action/types\";\nimport { createEvent } from \"../event\";\nimport { ActionResolverInterface, ResolveOptions } from \"./types\";\n\nexport class ActionResolver implements ActionResolverInterface {\n  callSubscribersLazy: boolean;\n\n  constructor({\n    callSubscribersLazy = false\n  }: { callSubscribersLazy?: boolean } = {}) {\n    this.callSubscribersLazy = callSubscribersLazy;\n  }\n\n  resolve({\n    action,\n    callSubscribers,\n    applyMutator,\n    setAction\n  }: ResolveOptions): Action | undefined {\n    action.event = createEvent();\n\n    applyMutator(action as Action);\n\n    setAction(action as Action);\n    if (!this.callSubscribersLazy || action.event.tagsSet) {\n      callSubscribers();\n    }\n\n    return action as Action;\n  }\n}\n\nexport abstract class AbstractActionResolverDecorator\n  implements ActionResolverInterface {\n  _actionResolver: ActionResolverInterface;\n\n  constructor({ actionResolver }: { actionResolver: ActionResolverInterface }) {\n    this._actionResolver = actionResolver;\n  }\n\n  resolve(options: ResolveOptions) {\n    return this._actionResolver.resolve(options);\n  }\n}\n","import { AbstractActionResolverDecorator } from \".\";\nimport { batchStart, batchEnd } from \"../observable\";\nimport { createEvent } from \"../event\";\nimport { BATCH_ACTION_TYPE } from \"../util/dispatchBatch\";\nimport { Action } from \"../action/types\";\nimport { ResolveOptions } from \"./types\";\n\nexport class BatchActionResolverDecorator extends AbstractActionResolverDecorator {\n  _eventByBatchId = {};\n  _childsByBatchId = {};\n  _observableBatchByBatchId = {};\n\n  resolve(options: ResolveOptions) {\n    const { store, setAction, applyMutator } = options;\n\n    if (\n      !options.action.meta.batchItem &&\n      options.action.type !== BATCH_ACTION_TYPE\n    ) {\n      return this._actionResolver.resolve(options);\n    }\n\n    const batchId = options.action.meta.batchId;\n    const rootBatchId = options.action.meta.rootBatchId;\n\n    options.action.event = this._eventByBatchId[rootBatchId] =\n      this._eventByBatchId[rootBatchId] || createEvent();\n    const action: Action = options.action as Action;\n    delete action.meta.batchId;\n    delete action.meta.rootBatchId;\n    delete action.meta.newBatch;\n    const parentBatchIds = options.action.meta.parentBatchIds;\n    delete action.meta.parentBatchIds;\n\n    if (action.meta.batchItem && action.type !== BATCH_ACTION_TYPE) {\n      if (this._observableBatchByBatchId[rootBatchId] == null) {\n        batchStart();\n        this._observableBatchByBatchId[rootBatchId] = true;\n      }\n      applyMutator(action);\n    }\n\n    if (action.type === BATCH_ACTION_TYPE) {\n      action.payload = this._childsByBatchId[batchId];\n      delete this._childsByBatchId[batchId];\n    }\n\n    if (action.meta.batchItem) {\n      if (action.type !== BATCH_ACTION_TYPE && parentBatchIds) {\n        for (const parentId of parentBatchIds) {\n          this._childsByBatchId[parentId] =\n            this._childsByBatchId[parentId] || [];\n          this._childsByBatchId[parentId].push(action);\n        }\n      }\n\n      delete action.meta.batchItem;\n\n      return action;\n    }\n\n    delete this._eventByBatchId[batchId];\n\n    if (this._observableBatchByBatchId[rootBatchId]) {\n      delete this._observableBatchByBatchId[rootBatchId];\n      batchEnd();\n    }\n\n    return this._actionResolver.resolve(options);\n  }\n}\n","import { isPromiseLike } from \".\";\nimport { StoreDispatchApi, Action } from \"../main/core\";\nimport { Thunk } from \"./types\";\n\nexport const typeThunk = <T extends Thunk>(thunk: T) => thunk;\n\nexport const dispatchThunk = function<\n  S extends StoreDispatchApi,\n  T extends Thunk<StoreDispatchApi<ReturnType<S[\"getState\"]>>>\n>(\n  store: S,\n  thunk: T\n): ReturnType<T> extends Promise<any> ? Promise<Action[]> : Action[] {\n  const dispatchedActions: Action[] = [];\n\n  const result = thunk({\n    getState: store.getState,\n    dispatch: function(action) {\n      const dispatchedAction = store.dispatch(action);\n      if (dispatchedAction) {\n        dispatchedActions.push(dispatchedAction);\n      }\n\n      return dispatchedAction;\n    }\n  });\n  if (isPromiseLike(result)) {\n    return result.then(function() {\n      return dispatchedActions;\n    }) as any;\n  }\n\n  return dispatchedActions as any;\n};\n","const toString = {}.toString;\n\nexport const isPlainObject = function(obj) {\n  return !!(obj && toString.call(obj) === \"[object Object]\");\n};\n","export * from \"../observable\";\nexport * from \"../observable/types\";\n","import { Action, NewAction, NormalizedAction } from \"../action/types\";\nimport { ActionNormalizer } from \"../actionNormalizer\";\nimport {\n  ActionNormalizerInterface,\n  NormalizeOptions\n} from \"../actionNormalizer/types\";\nimport { ActionResolver } from \"../actionResolver\";\nimport { ActionResolverInterface } from \"../actionResolver/types\";\nimport { DeepPartial } from \"../util/types\";\nimport { isAction } from \"../action\";\nimport { Listener, SubscribableInterface } from \"../subscribable/types\";\nimport { Mutator } from \"../mutator/types\";\nimport { setWildCard } from \"../event\";\nimport { StoreInterface } from \"./types\";\nimport { Subscribable } from \"../subscribable\";\nimport { cloneDeep as _cloneDeep, isPlainObject } from \"../util\";\nimport { observe, observable, batch } from \"../observable\";\nimport { PauseObserverFn } from \"../observable/types\";\n\nexport var actionTypes = {\n  INIT: \"@@init\"\n};\n\nexport class Store<T extends Mutator = Mutator> implements StoreInterface {\n  _isMutating: boolean;\n  _observable: {\n    state: any;\n  } = observable({\n    state: null\n  });\n  _action: Action;\n  _mutator: Mutator;\n  _actionNormalizer: ActionNormalizerInterface;\n  _actionResolver: ActionResolverInterface;\n  _subscribable: SubscribableInterface<Store<T>>;\n  _cloneDeep: typeof _cloneDeep;\n  _pureByDefault: boolean;\n\n  constructor({\n    mutator,\n    state,\n    actionNormalizer = new ActionNormalizer(),\n    actionResolver = new ActionResolver(),\n    subscribable = new Subscribable(),\n    cloneDeep = _cloneDeep,\n    pureByDefault = false\n  }: {\n    mutator: T;\n    state?: DeepPartial<ReturnType<ReturnType<T>>>;\n    actionNormalizer?: ActionNormalizerInterface;\n    actionResolver?: ActionResolverInterface;\n    subscribable?: SubscribableInterface<Store<T>>;\n    cloneDeep?: typeof _cloneDeep;\n    pureByDefault?: boolean;\n  }) {\n    this._actionResolver = actionResolver;\n    this._actionNormalizer = actionNormalizer;\n    this._subscribable = subscribable;\n    this._cloneDeep = cloneDeep;\n    this._pureByDefault = pureByDefault;\n\n    this._isMutating = false;\n    this._mutator = mutator;\n\n    // Initial set action\n    this.dispatch({\n      type: actionTypes.INIT,\n      meta: {\n        impure: true\n      },\n      payload: state\n    });\n  }\n\n  /**\n   * Returns the current state\n   */\n  getState = (): ReturnType<T> => {\n    return this._observable.state;\n  };\n\n  /**\n   * Get the last dispatched action\n   */\n  getAction(): Action {\n    return this._action;\n  }\n\n  subscribe(listener: Listener<this>, remember = false) {\n    return this._subscribable.subscribe(listener, remember);\n  }\n\n  getActionNormalizer() {\n    return this._actionNormalizer;\n  }\n\n  setActionNormalizer(actionNormalizer: ActionNormalizerInterface) {\n    this._actionNormalizer = actionNormalizer;\n  }\n\n  getActionResolver() {\n    return this._actionResolver;\n  }\n\n  setActionResolver(actionResolver: ActionResolverInterface) {\n    this._actionResolver = actionResolver;\n  }\n\n  getSubscribable() {\n    return this._subscribable;\n  }\n\n  setSubscribable(subscribable: SubscribableInterface<Store<T>>) {\n    this._subscribable = subscribable;\n  }\n\n  /**\n   * Send a message which will trigger an action\n   */\n  dispatch = (action: NewAction): Action | undefined => {\n    if (!isAction(action)) {\n      if (action) {\n        console.error(\"Invalid action dispatched\", action);\n      }\n\n      return;\n    }\n\n    if (!action.meta) action.meta = {};\n    if (!action.meta.tmp) action.meta.tmp = {};\n\n    return this._actionNormalizer.normalize({\n      action: action as NormalizedAction,\n      callBack: this._afterDispatchNormalization,\n      store: this\n    });\n  };\n\n  observe(func: (store: this, pauseObserverFn: PauseObserverFn) => any) {\n    return observe(pauseObserverFn => {\n      func(this, pauseObserverFn);\n    });\n  }\n\n  _callSubscribers = () => {\n    this._subscribable.callSubscribers(this);\n  };\n\n  _afterDispatchNormalization: NormalizeOptions[\"callBack\"] = action => {\n    return this._actionResolver.resolve({\n      action: action,\n      store: this,\n      setAction: this._setAction,\n      callSubscribers: this._callSubscribers,\n      applyMutator: this._applyMutator\n    });\n  };\n\n  _applyMutatorBatch(action: Action) {\n    const isInitAction = action.type === actionTypes.INIT;\n\n    if (isInitAction) {\n      this._observable.state = isPlainObject(action.payload)\n        ? observable(action.payload)\n        : action.payload;\n      setWildCard(action.event);\n    }\n\n    try {\n      let result = this._mutator(\n        this._observable.state,\n        action,\n        \"state\",\n        this._observable\n      );\n      // TODO: Maybe this should only happen if the user wants to use observables? Option-worthy?\n      if (isInitAction && isPlainObject(result)) {\n        result = observable(result);\n      }\n      this._observable.state = result;\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  _applyMutator = (action: Action) => {\n    let pureAction =\n      action.meta.pure != null ? action.meta.pure : this._pureByDefault;\n    let originalPayload = action.payload;\n    if (action.payload != null && !pureAction) {\n      action.payload = this._cloneDeep(originalPayload);\n    }\n\n    if (this._isMutating) {\n      throw new Error(\"Mutations already in progress\");\n    }\n\n    this._isMutating = true;\n\n    batch(() => {\n      this._applyMutatorBatch(action);\n    });\n\n    this._isMutating = false;\n\n    action.payload = originalPayload;\n  };\n\n  /**\n   * Override the last dispatched action\n   *\n   * @param action New action\n   */\n  _setAction = (action: Action) => {\n    this._action = action;\n  };\n}\n","\"use strict\";\nvar windowOrGlobal = Function('return this')();\n(function (root) {\n    /* istanbul ignore next */\n    if (typeof exports !== 'undefined') {\n        /* istanbul ignore next */\n        if (typeof module !== 'undefined' && module && module.exports) {\n            exports = module.exports = clone;\n        }\n        exports.clone = clone;\n    }\n    else {\n        /* istanbul ignore next */\n        root.clone = clone;\n    }\n    function clone(value) {\n        var type = typeof value;\n        switch (type) {\n            case 'object':\n                // null and undefined\n                if (value == null) {\n                    return value;\n                }\n                var result = void 0;\n                if (value instanceof Date) {\n                    result = new Date();\n                    result.setTime(value.getTime());\n                    return result;\n                }\n                else if (value instanceof RegExp) {\n                    result = newRegExp(value);\n                    return result;\n                }\n                result = JSON.parse(JSON.stringify(value));\n                fixTypes(value, result);\n                return result;\n            default:\n                return value;\n        }\n    }\n    function fixPropertyValue(original, copy, key) {\n        var originalValue = original[key];\n        var originalType = typeof originalValue;\n        switch (originalType) {\n            case 'object':\n                if (originalValue instanceof Date) {\n                    var newValue = new Date();\n                    newValue.setTime(originalValue.getTime());\n                    copy[key] = newValue;\n                }\n                else if (originalValue instanceof RegExp) {\n                    copy[key] = newRegExp(originalValue);\n                }\n                else if (originalValue == null) {\n                    copy[key] = originalValue;\n                }\n                else {\n                    fixTypes(originalValue, copy[key]);\n                }\n                break;\n            case 'number':\n                if (isNaN(originalValue)) {\n                    copy[key] = NaN;\n                }\n                else if (originalValue == Infinity) {\n                    copy[key] = Infinity;\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    function fixTypes(original, copy) {\n        if (original instanceof Array) {\n            for (var index = 0; index < original.length; index++) {\n                fixPropertyValue(original, copy, index);\n            }\n        }\n        else {\n            var keys = Object.getOwnPropertyNames(original);\n            keys.forEach(function (key) {\n                fixPropertyValue(original, copy, key);\n            });\n        }\n    }\n    function newRegExp(value) {\n        var regexpText = String(value);\n        var slashIndex = regexpText.lastIndexOf('/');\n        return new RegExp(regexpText.slice(1, slashIndex), regexpText.slice(slashIndex + 1));\n    }\n})(windowOrGlobal);\n","import { AbstractActionNormalizerDecorator } from \".\";\nimport { Action } from \"../action/types\";\nimport { NormalizeOptions } from \"./types\";\nimport { isAction, cloneAction } from \"../action\";\nimport { dispatchBatch, BATCH_ACTION_TYPE } from \"../util/dispatchBatch\";\nimport { StoreDispatchApi } from \"../store/types\";\n\n/**\n * Handles batch actions which are dispatched for a second time\n */\nexport class BatchActionNormalizerDecorator extends AbstractActionNormalizerDecorator {\n  normalize(options: NormalizeOptions) {\n    const { action, store } = options;\n\n    if (\n      !isAction(action) ||\n      action.type !== BATCH_ACTION_TYPE ||\n      action.meta.newBatch\n    ) {\n      return this._actionNormalizer.normalize(options);\n    }\n\n    let batchItems: Action[] = action.payload.map(action =>\n      cloneAction(action)\n    );\n    if (action.meta.undo) {\n      batchItems.reverse();\n    }\n\n    let storeProxy: StoreDispatchApi = {\n      getState: store.getState,\n      dispatch: function(childAction) {\n        childAction.meta = childAction.meta || {};\n\n        // Handle recursive batches\n        if (action.meta.batchId != null) {\n          childAction.meta.rootBatchId = action.meta.rootBatchId;\n          childAction.meta.parentBatchIds = action.meta.parentBatchIds;\n        }\n\n        if (\n          childAction.type === BATCH_ACTION_TYPE &&\n          !childAction.meta.batchItem\n        ) {\n          // This is the final new batch action created by \"dispatchBatch\"\n          // We now apply metas from our original batch options.action at the top\n          childAction.meta = { ...action.meta, ...childAction.meta };\n        }\n\n        return store.dispatch(childAction);\n      }\n    };\n\n    // For now we just use the dispatchBatch function to rehandle the old batch action\n    const newBatchAction = dispatchBatch(storeProxy, function(ds) {\n      for (const batchItem of batchItems) {\n        // Apply do/undo/redo signals from the batch action to its item\n        if (action.meta.undo) {\n          batchItem.meta.do = !batchItem.meta.do;\n          batchItem.meta.undo = !batchItem.meta.undo;\n        }\n        if (action.meta.redo && batchItem.meta.do) {\n          batchItem.meta.redo = true;\n        }\n\n        ds.dispatch(batchItem);\n      }\n    });\n\n    return newBatchAction;\n  }\n}\n","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","import { ActionNormalizerInterface, NormalizeOptions } from \"./types\";\n\nexport class ActionNormalizer implements ActionNormalizerInterface {\n  normalize({ action, callBack }: NormalizeOptions) {\n    if (!action.meta.undo && !action.meta.redo) action.meta.do = true;\n\n    return callBack(action);\n  }\n}\n\nexport abstract class AbstractActionNormalizerDecorator\n  implements ActionNormalizerInterface {\n  _actionNormalizer: ActionNormalizerInterface;\n\n  constructor({\n    actionNormalizer\n  }: {\n    actionNormalizer: ActionNormalizerInterface;\n  }) {\n    this._actionNormalizer = actionNormalizer;\n  }\n\n  normalize(options: NormalizeOptions) {\n    return this._actionNormalizer.normalize(options);\n  }\n}\n","import { Action } from \"../action/types\";\nimport { Mutator, MutatorsObj, MutatorsReturnObject } from \"./types\";\n\nexport const typeMutator = function<T extends Mutator<R>, R = any>(\n  consumer: T\n) {\n  return consumer;\n};\n\nexport const combineMutators = function<\n  TMutatorsObj extends MutatorsObj = MutatorsObj\n>(mutators: TMutatorsObj) {\n  const mutatorKeys = Object.keys(mutators);\n  const mutator = typeMutator(function(\n    state: Partial<MutatorsReturnObject<TMutatorsObj>> = {},\n    action: Action\n  ): MutatorsReturnObject<TMutatorsObj> {\n    for (const propName of mutatorKeys) {\n      (state as any)[propName] = mutators[propName](\n        state[propName],\n        action,\n        propName,\n        state\n      );\n    }\n\n    return state as any;\n  });\n\n  return mutator;\n};\n","import clone from \"fast-clone\";\n\nexport const isPromiseLike = function(promise): promise is Promise<any> {\n  return promise && (<Promise<any>>promise).then !== undefined;\n};\n\nexport var once = function(fn) {\n  var done = false;\n  var result;\n\n  return function() {\n    if (!done) {\n      result = fn();\n      done = true;\n    }\n\n    return result;\n  };\n};\n\nexport const findInArray = function(\n  values: any[],\n  predicate: (value, key, values) => any\n) {\n  let idx = 0;\n  for (const value of values) {\n    const result = predicate(value, idx, values);\n    if (result) {\n      return result;\n    }\n\n    idx++;\n  }\n};\n\nexport { isPlainObject } from \"./isPlainObject\";\n\nexport const cloneDeep = function(value) {\n  return clone(value);\n};\n","import { StoreDispatchApi, Action, NormalizedAction } from \"../main/core\";\nimport { isPromiseLike } from \".\";\nimport { BatchAction, Thunk } from \"./types\";\n\nconst resolveBatchAction = function(\n  store: StoreDispatchApi,\n  action: BatchAction\n): Action | undefined {\n  if (!action.payload) {\n    // No child actions were dispatched\n    return;\n  }\n\n  return store.dispatch(action);\n};\n\nexport const BATCH_ACTION_TYPE = \"@@batch\";\nlet batchIdx = 0;\nexport const dispatchBatch = function<\n  S extends StoreDispatchApi,\n  T extends Thunk<StoreDispatchApi<ReturnType<S[\"getState\"]>>>\n>(\n  store: S,\n  thunk: T\n): ReturnType<T> extends Promise<any>\n  ? Promise<Action | undefined>\n  : Action | undefined {\n  const batchId = batchIdx++;\n  const batchAction: BatchAction = {\n    type: BATCH_ACTION_TYPE,\n    payload: [],\n    meta: {\n      pure: true,\n      batchId,\n      rootBatchId: batchId,\n      batch: true,\n      newBatch: true\n    }\n  };\n\n  const result = thunk({\n    getState: store.getState,\n    dispatch: function(action) {\n      action.meta = action.meta || {};\n\n      if (action.meta.batchId == null) {\n        action.meta.batchId = batchAction.meta.batchId;\n      }\n\n      action.meta.rootBatchId = batchAction.meta.batchId;\n\n      action.meta.parentBatchIds = action.meta.parentBatchIds || [];\n      action.meta.parentBatchIds.push(batchAction.meta.batchId);\n\n      action.meta.batchItem = true;\n\n      return store.dispatch(action);\n    }\n  } as S);\n\n  if (isPromiseLike(result)) {\n    return result.then(function() {\n      return resolveBatchAction(store, batchAction);\n    }) as any;\n  }\n\n  return resolveBatchAction(store, batchAction) as any;\n};\n","import { StoreDispatchApi, NewAction, Action } from \"../main/core\";\n\nexport const dispatchPromise = function(\n  store: StoreDispatchApi,\n  promise: Promise<NewAction>\n): Promise<Action | undefined> {\n  return promise.then(function(action) {\n    return store.dispatch(action);\n  });\n};\n","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","import { AbstractActionNormalizerDecorator } from \".\";\nimport { NormalizeOptions } from \"./types\";\n\nexport class UndoableActionNormalizerDecorator extends AbstractActionNormalizerDecorator {\n  normalize(options: NormalizeOptions) {\n    if (options.action.meta.undoData) {\n      options.action.meta.undoData = { ...options.action.meta.undoData };\n    }\n\n    return this._actionNormalizer.normalize(options);\n  }\n}\n","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","export * from \"../store\";\nexport * from \"../store/types\";\n\nexport * from \"../action\";\nexport * from \"../action/types\";\n\nexport * from \"../event\";\nexport * from \"../event/types\";\n\nexport * from \"../mutator\";\nexport * from \"../mutator/types\";\n\nexport * from \"../undoable\";\nexport * from \"../undoable/types\";\n\nexport * from \"../subscribable\";\nexport * from \"../subscribable/types\";\n\nexport * from \"./observable\";\n\nexport * from \"../actionNormalizer\";\nexport * from \"../actionNormalizer/types\";\nexport * from \"../actionNormalizer/batchActionNormalizerDecorator\";\nexport * from \"../actionNormalizer/dateActionNormalizerDecorator\";\nexport * from \"../actionNormalizer/undoableActionNormalizerDecorator\";\n\nexport * from \"../actionResolver\";\nexport * from \"../actionResolver/types\";\nexport * from \"../actionResolver/batchActionResolverDecorator\";\n\nexport * from \"../util/dispatchBatch\";\nexport * from \"../util/dispatchThunk\";\nexport * from \"../util/dispatchPromise\";\nexport * from \"../util/dispatchActions\";\nexport * from \"../util/types\";\nexport { once, findInArray } from \"../util\";\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","import { actionTypes } from \"../store\";\nimport { NewAction } from \"../action/types\";\nimport { typeMutator } from \"../mutator\";\nimport { typeThunk } from \"../util/dispatchThunk\";\nimport {\n  UndoableAction,\n  UndoRedoAction,\n  ActionFilter,\n  UndoableMutatorState\n} from \"./types\";\nimport { observable, notify } from \"../observable\";\n\nexport const setUndoData = function(\n  action: UndoableAction,\n  key: string | number,\n  value?: any\n) {\n  const undoData = (action.meta.undoData = action.meta.undoData || {});\n  if (action.meta.do) undoData[key] = value;\n\n  return undoData[key];\n};\n\nexport const getUndoData = function(\n  action: UndoableAction,\n  key: string | number\n) {\n  const undoData = (action.meta.undoData = action.meta.undoData || {});\n\n  return undoData[key];\n};\n\nconst setUndoableCache = function(action: UndoRedoAction, value: NewAction) {\n  action.meta = action.meta || {};\n  action.meta.undoableCache = value;\n};\n\nconst undoActionTypePrefix = \"@@undo_\";\nconst redoActionTypePrefix = \"@@redo_\";\n\nexport const createUndoThunk = function(id) {\n  return typeThunk(store => {\n    const action = store.dispatch({\n      type: undoActionTypePrefix + id\n    });\n    if (action && action.meta && action.meta.undoableCache) {\n      store.dispatch({\n        type: action.meta.undoableCache.type,\n        payload: action.meta.undoableCache.payload,\n        meta: action.meta.undoableCache.meta\n      });\n      delete action.meta.undoableCache;\n    }\n  });\n};\n\nexport const createRedoThunk = function(id) {\n  return typeThunk(store => {\n    const action = store.dispatch({\n      type: redoActionTypePrefix + id\n    });\n    if (action && action.meta && action.meta.undoableCache) {\n      store.dispatch({\n        type: action.meta.undoableCache.type,\n        payload: action.meta.undoableCache.payload,\n        meta: action.meta.undoableCache.meta\n      });\n      delete action.meta.undoableCache;\n    }\n  });\n};\n\nexport const createUndoableMutator = function({\n  id,\n  actionFilter\n}: {\n  id: string;\n  actionFilter?: ActionFilter;\n}) {\n  return typeMutator(function(\n    state: UndoableMutatorState = observable({ past: [], future: [] }),\n    action\n  ) {\n    if (action.type === undoActionTypePrefix + id) {\n      // Handle undo\n\n      if (state.past.length === 0) {\n        return state;\n      }\n\n      const pastAction = state.past.pop();\n      notify(state, \"past\");\n\n      if (!pastAction) {\n        console.log(\"this actually happens\");\n        return state;\n      }\n\n      setUndoableCache(action, {\n        type: pastAction.type,\n        payload: pastAction.payload,\n        meta: { ...pastAction.meta, do: false, redo: false, undo: true }\n      });\n\n      state.future.push(pastAction);\n      notify(state, \"future\");\n    } else if (action.type === redoActionTypePrefix + id) {\n      // Handle redo\n\n      if (state.future.length === 0) {\n        return state;\n      }\n\n      const futureAction = state.future.pop();\n      notify(state, \"future\");\n\n      if (!futureAction) {\n        return state;\n      }\n\n      setUndoableCache(action, {\n        type: futureAction.type,\n        payload: futureAction.payload,\n        meta: { ...futureAction.meta, do: true, redo: true, undo: false }\n      });\n\n      state.past.push(futureAction);\n      notify(state, \"past\");\n    } else {\n      // Handle new actions\n\n      if (action.type == actionTypes.INIT) {\n        return state;\n      }\n\n      if (action.meta.undo || action.meta.redo) {\n        return state;\n      }\n\n      if (actionFilter && !actionFilter(action)) {\n        return state;\n      }\n\n      state.future = [];\n      notify(state, \"future\");\n\n      state.past.push({\n        type: action.type,\n        payload: action.payload,\n        meta: action.meta\n      });\n      notify(state, \"past\");\n    }\n\n    return state;\n  });\n};\n","// Originally created by dongwoo-kim (https://github.com/dongwoo-kim)\n// https://github.com/nhn/tui.grid/blob/55278fba5303fcef928715cbb003aeed0964dd29/src/helper/observable.ts\n\nimport { Dictionary } from \"../util/types\";\nimport {\n  ObserverInfo,\n  ObservableInfo,\n  Observable,\n  BooleanSet,\n  ObserveFn,\n  PauseObserverFn\n} from \"./types\";\nimport { isPlainObject } from \"../util/isPlainObject\";\n\nlet nextId = 0;\nconst generateUniqueId = function() {\n  return `${nextId++}`;\n};\n\n// store all observer info\nconst observerInfoMap: Dictionary<ObserverInfo> = {};\n\nconst observableInfoMap: Dictionary<ObservableInfo<any>> = {};\n\nfunction isObservable<T>(resultObj: T): resultObj is Observable<T> {\n  return (\n    resultObj !== null &&\n    typeof resultObj === \"object\" &&\n    resultObj[\"__observableId\"] != null\n  );\n}\n\nexport const pauseObserver: PauseObserverFn = function(pause = true) {\n  if (!currentObserver.id) return;\n\n  currentObserver.pause = pause;\n};\n\nconst currentObserver: { id: null | string; pause: boolean } = {\n  id: null,\n  pause: false\n};\nfunction callObserver(observerId: string) {\n  let previousId = currentObserver.id;\n  let previousPause = currentObserver.pause;\n\n  currentObserver.pause = false;\n  currentObserver.id = observerId;\n\n  const observerInfo = observerInfoMap[observerId];\n\n  if (observerInfo.running) {\n    console.error(\"Bad observer\", observerInfo.fn);\n    throw new Error(`Bad recursion detected in observer`);\n  }\n\n  observerInfo.running = true;\n  observerInfo.fn(pauseObserver);\n  observerInfo.running = false;\n\n  currentObserver.id = previousId;\n  currentObserver.pause = previousPause;\n}\n\nfunction setValue<T, K extends keyof T>(\n  storage: T,\n  observerIdSet: BooleanSet,\n  key: keyof T,\n  value: T[K]\n) {\n  if (storage[key] !== value) {\n    storage[key] = value;\n    notifyObservers(Object.keys(observerIdSet));\n  }\n}\n\nexport function observe(\n  fn: ObserveFn,\n  notifyInBatches: string | boolean = false\n) {\n  const observerId = generateUniqueId();\n  observerInfoMap[observerId] = {\n    running: false,\n    notifyInBatches,\n    fn,\n    targetObserverIdSets: []\n  };\n  callObserver(observerId);\n\n  // return unobserve function\n  return () => {\n    observerInfoMap[observerId].targetObserverIdSets.forEach(idSet => {\n      delete idSet[observerId];\n    });\n  };\n}\n\nexport const removeProp = function<\n  T extends Observable<any>,\n  K extends keyof T\n>(obj: T, key: K) {\n  const { storage, propObserverIdSetMap } = observableInfoMap[\n    obj.__observableId\n  ];\n  delete storage[key];\n  delete obj[key];\n  delete propObserverIdSetMap[key as any];\n};\n\nexport const setProp = function<T extends Observable<any>, K extends keyof T>(\n  obj: T,\n  key: K,\n  value: T[K],\n  deep = false\n) {\n  const { storage, propObserverIdSetMap } = observableInfoMap[\n    obj.__observableId\n  ];\n  const observerIdSet: BooleanSet = (propObserverIdSetMap[key as any] =\n    propObserverIdSetMap[key as any] || {});\n\n  if (deep) {\n    if (Array.isArray(value)) {\n      for (const itemKey of Object.keys(value)) {\n        var itemValue = value[itemKey];\n        if (!isPlainObject(itemValue)) {\n          continue;\n        }\n\n        value[itemKey] = observable(itemValue);\n      }\n    } else if (isPlainObject(value)) {\n      value = observable(value);\n    }\n  }\n\n  if (storage[key] !== undefined && obj[key] !== undefined) {\n    // TODO: Remove this console.log?\n    console.log(\"already existing\");\n    setValue(storage, observerIdSet, key, value);\n    return;\n  }\n\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      // The current observer is paused for registering get calls (triggered by pauseObserver)\n      if (currentObserver.pause) {\n        return storage[key];\n      }\n\n      const observerId = currentObserver.id;\n      // There is no active observer, or the current observer is already tracked\n      if (!observerId || observerIdSet[observerId]) {\n        return storage[key];\n      }\n\n      // An observer asked for a property on the observable, we have to track this\n      observerIdSet[observerId] = true;\n      observerInfoMap[observerId].targetObserverIdSets.push(observerIdSet);\n\n      return storage[key];\n    }\n  });\n\n  (storage as any)[key] = value;\n  Object.defineProperty(obj, key, {\n    set(value) {\n      setValue(storage, observerIdSet, key, value);\n    }\n  });\n};\n\nexport function observable<T extends Dictionary<any>>(\n  obj: T,\n  deep: boolean = true\n): Observable<T> {\n  if (isObservable(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    throw new Error(\"Array object cannot be Reactive\");\n  }\n\n  const observableId = generateUniqueId();\n  const resultObj = {} as T;\n\n  observableInfoMap[observableId] = {\n    storage: {},\n    propObserverIdSetMap: {}\n  };\n\n  Object.defineProperty(resultObj, \"__observableId\", {\n    value: observableId\n  });\n\n  for (const key of Object.keys(obj)) {\n    setProp(resultObj, key, obj[key], deep);\n  }\n\n  return resultObj as Observable<T>;\n}\n\n// Used to optimize observer-to-observer calls:\n// For nested notifyObservers calls, the observers will be called only once in the most outward notifyObservers call\nconst plannedObserverCalls = {};\nlet nextPlanIdx = 0;\nconst notifyObservers = function(observerIds: string[]) {\n  let planIdx = nextPlanIdx++;\n\n  let notify = true;\n  if (batchInfo.count > 0) {\n    notify = false;\n  }\n\n  for (const observerId of observerIds) {\n    if (plannedObserverCalls[observerId] != null) {\n      continue;\n    }\n\n    plannedObserverCalls[observerId] = planIdx;\n  }\n  for (const observerId of observerIds) {\n    const notifyInBatches = observerInfoMap[observerId].notifyInBatches;\n    if (\n      notify ||\n      notifyInBatches === true ||\n      notifyInBatches === batchInfo.batchId\n    ) {\n      if (plannedObserverCalls[observerId] !== planIdx) {\n        continue;\n      }\n      callObserver(observerId);\n    } else {\n      if (batchInfo.observerIds.indexOf(observerId) === -1) {\n        batchInfo.observerIds.push(observerId);\n      }\n    }\n\n    delete plannedObserverCalls[observerId];\n  }\n};\n\nexport function notify<T extends Observable<any>, K extends keyof T>(\n  obj: T,\n  key: K\n) {\n  if (isObservable(obj)) {\n    const propObserverIdSetMap =\n      observableInfoMap[obj.__observableId].propObserverIdSetMap[key as string];\n    notifyObservers(Object.keys(propObserverIdSetMap));\n  }\n}\n\nconst batchInfo: { count: number; observerIds: string[]; batchId: any } = {\n  count: 0,\n  observerIds: [],\n  batchId: null\n};\nexport const batch = function(fn: () => void) {\n  batchStart();\n  fn();\n  batchEnd();\n};\n\nexport const batchStart = function() {\n  batchInfo.count++;\n};\n\nexport const batchEnd = function() {\n  if (batchInfo.count === 0) return;\n\n  batchInfo.count--;\n  if (batchInfo.count === 0) {\n    let observerIds = batchInfo.observerIds;\n    batchInfo.observerIds = [];\n    notifyObservers(observerIds);\n  }\n};\n\nexport function getOriginObject<T>(obj: Observable<T>) {\n  const result = {} as T;\n  const storage = observableInfoMap[obj.__observableId].storage;\n  for (const key of Object.keys(storage)) {\n    const value = storage[key];\n    result[key] = isObservable(value) ? getOriginObject(value) : value;\n  }\n\n  return result;\n}\n\nlet computationBatchIdx = 0;\nexport const computation = function<\n  P extends {\n    [key: string]: (\n      obj: any,\n      value: any,\n      key: any,\n      pauseObserver: PauseObserverFn,\n      init: boolean\n    ) => any;\n  }\n>(\n  propsObj: P,\n  batch: boolean = true\n): [{ [K in keyof P]: ReturnType<P[K]> }, () => void] {\n  const batchId = \"computation-\" + computationBatchIdx++;\n\n  let obj = {};\n  const objKeys = Object.keys(propsObj);\n  for (const key of objKeys) {\n    obj[key] = null;\n  }\n\n  obj = observable(obj, false);\n\n  let subscriptions = [] as Function[];\n  let unsubscribed = false;\n  const unsubscribeFn = function() {\n    if (unsubscribed) return;\n    for (const subscription of subscriptions) {\n      subscription();\n    }\n    unsubscribed = true;\n  };\n\n  for (const key of objKeys) {\n    let init = true;\n    subscriptions.push(\n      observe(function(pauseObserver) {\n        let prevBatchId = batchInfo.batchId;\n        if (batch) {\n          batchStart();\n          batchInfo.batchId = batchId;\n        }\n\n        obj[key] = propsObj[key](\n          obj,\n          observableInfoMap[obj[\"__observableId\"]].storage[key],\n          key,\n          pauseObserver,\n          init\n        );\n\n        if (batch) {\n          batchEnd();\n          batchInfo.batchId = prevBatchId;\n        }\n      }, batchId)\n    );\n    init = false;\n  }\n\n  return [obj as any, unsubscribeFn];\n};\n\ncomputation.empty = function(): any {};\n\nexport const extract = function(observable, deep = true) {\n  let result = observable;\n\n  if (Array.isArray(observable)) {\n    result = [];\n    for (let value of observable) {\n      if (deep) {\n        value = extract(value, deep);\n      }\n      result.push(value);\n    }\n  } else if (isObservable(observable)) {\n    result = {};\n    for (const key of Object.keys(observable)) {\n      let value = observable[key];\n      if (deep) {\n        value = extract(value, deep);\n      }\n      result[key] = value;\n    }\n  }\n\n  return result;\n};\n","import { AbstractActionNormalizerDecorator } from \".\";\nimport { NormalizeOptions } from \"./types\";\n\nexport class DateActionNormalizerDecorator extends AbstractActionNormalizerDecorator {\n  normalize(options: NormalizeOptions) {\n    options.action.meta.date = new Date();\n\n    return this._actionNormalizer.normalize(options);\n  }\n}\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","import { NewAction, Action, NormalizedAction } from \"./types\";\n\nexport const isAction = function(action): action is NewAction {\n  return action && (<NewAction>action).type !== undefined;\n};\n\nexport const cloneAction = function(\n  action: NormalizedAction | Action\n): NormalizedAction {\n  return {\n    ...action,\n    event: undefined,\n    meta: {\n      ...action.meta,\n      tmp: {}\n    }\n  };\n};\n","import { Event, Tag, EntityId, Entity } from \"./types\";\nimport { Action } from \"../action/types\";\n\nlet idx = 0;\nlet parentByTag = {};\nlet entityContainerByTag = {};\nlet childrenByTag = {};\n\nconst registerEntityContainer = function(containerTag: Tag, tag: Tag) {\n  entityContainerByTag[tag] = containerTag;\n  if (childrenByTag[tag]) {\n    for (const child of childrenByTag[tag]) {\n      registerEntityContainer(containerTag, child);\n    }\n  }\n};\n\nexport const createTag = function({\n  name = \"\",\n  children,\n  entityContainer = false\n}: {\n  name?: string;\n  children?: Tag[];\n  entityContainer?: boolean;\n} = {}): Tag {\n  const tag = `${idx++}-${name}`;\n\n  if (children) {\n    setTagChildren(tag, children, entityContainer);\n  }\n\n  return tag;\n};\n\nexport const setTagChildren = function(\n  tag: Tag,\n  children: Tag[],\n  entityContainer = false\n) {\n  childrenByTag[tag] = children;\n\n  for (const child of children) {\n    parentByTag[child] = tag;\n    if (entityContainer) {\n      registerEntityContainer(tag, child);\n    }\n  }\n};\n\nconst getTagEntity = function(\n  event: Event,\n  tag: Tag,\n  entityId: EntityId,\n  initialize = false\n): Entity | undefined {\n  const containerTag = entityContainerByTag[tag];\n  if (!containerTag) return;\n\n  if (initialize) {\n    const container = (event.containers[containerTag] =\n      event.containers[containerTag] || {});\n    return (container[entityId] = container[entityId] || {});\n  } else {\n    const container = event.containers[containerTag];\n    if (!container) return;\n    return container[entityId];\n  }\n};\n\nexport const setWildCard = function(\n  subject: Event | Action,\n  tag: Tag = \"\",\n  entityId?: EntityId\n) {\n  const event: Event =\n    (subject as Action).type !== undefined\n      ? (subject as Action).event\n      : (subject as Event);\n\n  event.tagsSet = true;\n\n  event.tags[tag + \"*\"] = true;\n\n  if (entityId != null) {\n    const entity = getTagEntity(event, tag, entityId, true);\n    if (entity) {\n      entity[tag + \"*\"] = true;\n    }\n  }\n};\n\nexport const setTag = function(\n  subject: Event | Action,\n  tag: Tag,\n  entityId?: EntityId,\n  entity?: Entity\n) {\n  const event: Event =\n    (subject as Action).type !== undefined\n      ? (subject as Action).event\n      : (subject as Event);\n\n  event.tagsSet = true;\n\n  event.tags[tag] = event.tags[tag] || true;\n\n  if (entityId != null) {\n    entity = entity || getTagEntity(event, tag, entityId, true);\n    if (entity) {\n      entity[tag] = true;\n    }\n  }\n\n  const parentTag = parentByTag[tag];\n  if (parentTag && !event.tags[parentTag]) {\n    setTag(event, parentTag, entityId);\n  }\n};\n\nconst parentWildCardIsSet = function(\n  event: Event,\n  childTag: Tag,\n  entity?: Entity\n) {\n  while (true) {\n    childTag = parentByTag[childTag];\n    if (!childTag) {\n      return false;\n    }\n\n    if (entity && entity[childTag + \"*\"]) {\n      return true;\n    }\n\n    if (event.tags[childTag + \"*\"]) {\n      return true;\n    }\n  }\n};\n\nexport const tagIsSet = function(\n  subject: Event | Action,\n  tag: Tag,\n  entityId?: EntityId,\n  checkWildCard = true\n) {\n  const event: Event =\n    (subject as Action).type !== undefined\n      ? (subject as Action).event\n      : (subject as Event);\n\n  if (checkWildCard && event.tags[\"*\"]) {\n    return true;\n  }\n\n  let tagIsSet = event.tags[tag];\n  let entity;\n\n  if (entityId != null) {\n    entity = getTagEntity(event, tag, entityId);\n    if (entity) {\n      tagIsSet = entity[tag];\n    } else {\n      tagIsSet = false;\n    }\n  }\n\n  const wildCardIsSet =\n    !tagIsSet && checkWildCard && parentWildCardIsSet(event, tag, entity);\n\n  return !!(tagIsSet || wildCardIsSet);\n};\n\nexport const createEvent = function(): Event {\n  return {\n    tagsSet: false,\n    tags: {},\n    containers: {}\n  };\n};\n","import { StoreDispatchApi, NewAction, Action } from \"../main/core\";\n\nexport const dispatchActions = function(\n  store: StoreDispatchApi,\n  actions: NewAction[]\n) {\n  let result: Action[] = [];\n\n  for (const action of actions) {\n    const dispatchedAction = store.dispatch(action);\n    if (dispatchedAction) {\n      result.push(dispatchedAction);\n    }\n  }\n\n  return result;\n};\n","import { SubscribableInterface, Listener } from \"./types\";\n\n/**\n * Implements a very basic and general subscribable:\n * a list of listeners which will be called in specific moments - moments defined by the child class\n * New listeners will not be directly called, when they are subscribed while a broadcast is happening\n */\nexport class Subscribable<T = any> implements SubscribableInterface<T> {\n  _currentListeners: Function[];\n  _nextListeners: Function[];\n  _lastListenerOptions?: T;\n  _subscribersCalled = false;\n\n  constructor() {\n    this._currentListeners = [];\n    // Will be copied shallowly from currentListeners by _separateNextListeners\n    this._nextListeners = this._currentListeners;\n  }\n\n  /**\n   * Creates a copy of currentListeners for the futureListeners (Look at subscribe for more information)\n   */\n  _separateNextListeners() {\n    if (this._currentListeners === this._nextListeners) {\n      this._nextListeners = this._currentListeners.slice();\n    }\n  }\n\n  /**\n   * Adds a function to the subscribers list.\n   *\n   * The function gets called with the store as a parameter\n   *\n   * If subscribe is called in an other listener and is therefore in a _callSubscribers call,\n   * the new listener will only be called in future _callSubscribers calls!\n   *\n   * @param {function} listener\n   */\n  subscribe(listener: Listener<T>, remember = false) {\n    this._separateNextListeners();\n    var isSubscribed = true;\n    this._nextListeners.push(listener);\n\n    if (remember && this._subscribersCalled) {\n      listener(this._lastListenerOptions as T);\n    }\n\n    return function() {\n      if (isSubscribed) {\n        isSubscribed = false;\n        this._separateNextListeners();\n        var index = this._nextListeners.indexOf(listener);\n        this._nextListeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Should be called by the child class, when a broadcast to the subscribers should occur\n   * This also sets the listeners registered in nextListeners as currentListeners\n   */\n  callSubscribers(listenerOptions: T) {\n    this._subscribersCalled = true;\n    this._lastListenerOptions = listenerOptions;\n    this._currentListeners = this._nextListeners;\n    for (var listener of this._currentListeners) {\n      listener(listenerOptions);\n    }\n  }\n}\n\n/**\n * Callback used by _callSubscribers\n * @callback listenerCallback\n * @param {Store} store\n *\n * TODO: This notation currently doesnt work with vscode https://github.com/Microsoft/TypeScript/issues/7515\n */\n"],"sourceRoot":""}