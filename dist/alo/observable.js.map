{"version":3,"sources":["webpack://alo.[name]/webpack/universalModuleDefinition","webpack://alo.[name]/webpack/bootstrap","webpack://alo.[name]/./lib/alo/main/observable.ts","webpack://alo.[name]/./node_modules/lodash/_getRawTag.js","webpack://alo.[name]/./node_modules/lodash/isObjectLike.js","webpack://alo.[name]/./node_modules/lodash/_objectToString.js","webpack://alo.[name]/./node_modules/lodash/_root.js","webpack://alo.[name]/./node_modules/lodash/_getPrototype.js","webpack://alo.[name]/./node_modules/lodash/_baseGetTag.js","webpack://alo.[name]/./node_modules/lodash/_freeGlobal.js","webpack://alo.[name]/./node_modules/lodash/isPlainObject.js","webpack://alo.[name]/./node_modules/@babel/runtime/helpers/typeof.js","webpack://alo.[name]/./lib/alo/observable/index.ts","webpack://alo.[name]/./node_modules/lodash/_overArg.js","webpack://alo.[name]/./node_modules/lodash/_Symbol.js","webpack://alo.[name]/(webpack)/buildin/global.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","objectProto","nativeObjectToString","toString","symToStringTag","undefined","isOwn","tag","unmasked","e","result","freeGlobal","freeSelf","Function","getPrototype","overArg","getPrototypeOf","getRawTag","objectToString","global","baseGetTag","isObjectLike","funcProto","funcToString","objectCtorString","proto","Ctor","constructor","_typeof","obj","iterator","nextId","generateUniqueId","PARENT_KEY","ID_KEY","observerInfoMap","observableInfoMap","isObservable","resultObj","pauseObserver","pause","currentObserver","id","observerStart","observerId","observerInfo","running","observerEnd","console","error","fn","Error","previousObserverId","previousObserverPause","callObserver","autoStart","notifyParent","getParentInfo","parentInfo","notify","parent","unobserve","targetObserverIdSets","forEach","idSet","observe","notifyInBatches","removeProp","__observableId","propObserverIdSetMap","propGetterMap","getProp","arrayProto","Array","arrayMethods","method","original","args","inserted","apply","slice","observableArray","parentObj","__proto__","keys","itemKey","observableValue","isObservableValue","isArray","observable","configurable","setProp","getOwnPropertyDescriptor","setter","set","observerIdSet","firstChar","push","newValue","notifyObservers","observableId","plannedObserverCalls","nextPlanIdx","observerIds","planIdx","batchInfo","count","batchIdMap","indexOf","batch","batchId","batchStart","batchEnd","computationBatchIdx","computation","propsObj","objKeys","unsubscribed","unsubscribeFn","init","extract","deep","func","transform","arg","g","window"],"mappings":"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","file":"observable.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"observable\"] = factory();\n\telse\n\t\troot[\"alo\"] = root[\"alo\"] || {}, root[\"alo\"][\"observable\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"2VHu\");\n","export * from \"../observable\";\nexport * from \"../observable/types\";\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","// Originally created by dongwoo-kim (https://github.com/dongwoo-kim)\n// https://github.com/nhn/tui.grid/blob/55278fba5303fcef928715cbb003aeed0964dd29/src/helper/observable.ts\n\nimport {\n  ObserverInfo,\n  ObservableInfo,\n  Observable,\n  BooleanSet,\n  ObserveFn,\n  PauseObserverFn,\n  ComputationMap,\n  ComputationValues\n} from \"./types\";\n\nimport _ from \"lodash\";\n\nlet nextId = 0;\nconst generateUniqueId = function() {\n  return `${nextId++}`;\n};\n\nconst PARENT_KEY = \"__observableParent\";\nconst ID_KEY = \"__observableId\";\n\n// store all observer info\nconst observerInfoMap: Record<string, ObserverInfo> = {};\n\nconst observableInfoMap: Record<string, ObservableInfo<any>> = {};\n\nexport const isObservable = function<T>(\n  resultObj: T\n): resultObj is Observable<T> {\n  return (\n    resultObj !== null &&\n    typeof resultObj === \"object\" &&\n    resultObj[ID_KEY] != null\n  );\n};\n\nexport const pauseObserver: PauseObserverFn = function(pause = true) {\n  if (!currentObserver.id) return;\n\n  currentObserver.pause = pause;\n};\n\nexport const observerStart = function(observerId: string) {\n  const observerInfo = observerInfoMap[observerId];\n\n  if (observerInfo.running) {\n    if (currentObserver.id) {\n      observerEnd(currentObserver.id);\n    }\n    console.error(\"Bad observer\", observerInfo.fn);\n    throw new Error(`Bad recursion detected in observer`);\n  }\n\n  observerInfo.previousObserverId = currentObserver.id;\n  observerInfo.previousObserverPause = currentObserver.pause;\n\n  currentObserver.pause = false;\n  currentObserver.id = observerId;\n\n  observerInfo.running = true;\n};\n\nexport const observerEnd = function(observerId: string) {\n  const observerInfo = observerInfoMap[observerId];\n  observerInfo.running = false;\n  currentObserver.id = observerInfo.previousObserverId;\n  currentObserver.pause = observerInfo.previousObserverPause;\n};\n\nconst currentObserver: { id: null | string; pause: boolean } = {\n  id: null,\n  pause: false\n};\nfunction callObserver(observerId: string) {\n  const observerInfo = observerInfoMap[observerId];\n\n  if (observerInfo.autoStart) {\n    observerStart(observerId);\n  }\n\n  observerInfo.fn(pauseObserver);\n\n  if (observerInfo.autoStart) {\n    observerEnd(observerId);\n  }\n}\n\nconst notifyParent = function(obj) {\n  const getParentInfo = obj[PARENT_KEY];\n  if (!getParentInfo) {\n    return;\n  }\n\n  const parentInfo = getParentInfo();\n\n  notify(parentInfo.parent, parentInfo.key);\n};\n\nexport const unobserve = function(observerId) {\n  observerInfoMap[observerId].targetObserverIdSets.forEach(idSet => {\n    delete idSet[observerId];\n  });\n};\n\nexport function observe(\n  fn: ObserveFn,\n  notifyInBatches: string | boolean = false,\n  autoStart = true\n) {\n  const observerId = generateUniqueId();\n  observerInfoMap[observerId] = {\n    running: false,\n    autoStart,\n    previousObserverId: null,\n    previousObserverPause: false,\n    notifyInBatches,\n    fn,\n    targetObserverIdSets: []\n  };\n\n  if (autoStart) {\n    callObserver(observerId);\n  }\n\n  // return unobserve function\n  return observerId;\n}\n\nexport const removeProp = function<\n  T extends Observable<any>,\n  K extends keyof T\n>(obj: T, key: K) {\n  const { propObserverIdSetMap, propGetterMap } = observableInfoMap[\n    obj.__observableId\n  ];\n  delete obj[key];\n  delete propGetterMap[key];\n  delete propObserverIdSetMap[key as any];\n\n  notifyParent(obj);\n};\n\n/**\n * Silently get an observable property value (observer will not track it)\n *\n * @param obj Observable obj\n * @param key Property key\n */\nexport const getProp = function<T extends Observable<any>, K extends keyof T>(\n  obj: T,\n  key: K\n): T[K] {\n  const { propGetterMap } = observableInfoMap[obj.__observableId];\n\n  return propGetterMap[key]();\n};\n\nconst arrayProto = Array.prototype;\nconst arrayMethods = Object.create(arrayProto);\n\nconst methodsToPatch = [\n  \"push\",\n  \"pop\",\n  \"shift\",\n  \"unshift\",\n  \"splice\",\n  \"sort\",\n  \"reverse\"\n];\n\nmethodsToPatch.forEach(function(method) {\n  // cache original method\n  const original = arrayProto[method];\n  arrayMethods[method] = function(...args) {\n    const result = original.apply(this, args);\n\n    const { parent, key } = this[PARENT_KEY]();\n\n    let inserted;\n    switch (method) {\n      case \"push\":\n      case \"unshift\":\n        inserted = args;\n        break;\n      case \"splice\":\n        inserted = args.slice(2);\n        break;\n    }\n\n    if (inserted) observableArray(inserted, key, parent);\n\n    notify(parent, key);\n\n    return result;\n  };\n});\n\nconst observableArray = function<T extends Observable<any>, K extends keyof T>(\n  value: any[],\n  key: K,\n  parentObj: T\n) {\n  (value as any).__proto__ = arrayMethods;\n\n  for (const itemKey of Object.keys(value)) {\n    value[itemKey] = observableValue(value[itemKey], key, parentObj);\n  }\n\n  return value;\n};\n\nconst observableValue = function(value, key, parent) {\n  let isObservableValue = false;\n\n  if (Array.isArray(value)) {\n    value = observableArray(value, key, parent);\n    isObservableValue = true;\n  } else if (_.isPlainObject(value)) {\n    value = observable(value, key, parent);\n    isObservableValue = true;\n  }\n\n  if (isObservableValue) {\n    // TODO: Maybe we could check if the parent already is set & uptodate\n    Object.defineProperty(value, PARENT_KEY, {\n      configurable: true,\n      value: function() {\n        return { parent, key };\n      }\n    });\n  }\n\n  return value;\n};\n\nexport const setProp = function<\n  T extends Observable<any> | any[],\n  K extends keyof T\n>(obj: T, key: K, value: T[K]) {\n  if (obj[PARENT_KEY] && obj[ID_KEY] === undefined) {\n    obj[key] = observableValue(value, key, obj);\n    notifyParent(obj);\n    return;\n  }\n\n  const { propObserverIdSetMap, propGetterMap } = observableInfoMap[\n    obj.__observableId\n  ];\n\n  // If there already is a getter existing, then this prop is already observable\n  if (propGetterMap[key]) {\n    obj[key] = value;\n    return;\n  }\n\n  const property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  const getter = property && property.get;\n  const setter = property && property.set;\n\n  /*\n  TODO: Maybe in the future we could allow calling setProp without a value\n  if ((!getter || setter) && arguments.length === 2) {\n    value = obj[key]\n  }\n  */\n\n  // This function can be used to access the value externally without triggering observers\n  propGetterMap[key] = function() {\n    return getter ? getter.call(obj) : value;\n  };\n\n  const observerIdSet: BooleanSet = (propObserverIdSetMap[key as any] =\n    propObserverIdSetMap[key as any] || {});\n\n  const firstChar = key[0];\n  const isObservableValue = firstChar !== \"$\" && firstChar !== \"_\";\n\n  value = isObservableValue ? observableValue(value, key, obj) : value;\n\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const result = getter ? getter.call(obj) : value;\n\n      // The current observer is paused for registering get calls (triggered by pauseObserver)\n      if (currentObserver.pause) {\n        return result;\n      }\n\n      const observerId = currentObserver.id;\n      // There is no active observer, or the current observer is already tracked\n      if (!observerId || observerIdSet[observerId]) {\n        return result;\n      }\n\n      // An observer asked for a property on the observable, we have to track this\n      observerIdSet[observerId] = true;\n      observerInfoMap[observerId].targetObserverIdSets.push(observerIdSet);\n\n      return result;\n    }\n  });\n\n  Object.defineProperty(obj, key, {\n    set(newValue) {\n      const oldValue = getter ? getter.call(obj) : value;\n      if (oldValue === newValue) {\n        return;\n      }\n\n      newValue = isObservableValue\n        ? observableValue(newValue, key, obj)\n        : newValue;\n\n      if (setter) {\n        setter.call(obj, newValue);\n      } else {\n        value = newValue;\n      }\n      notifyObservers(Object.keys(observerIdSet));\n    }\n  });\n\n  notifyParent(obj);\n};\n\nexport function observable<T extends Record<string, any>>(\n  obj: T,\n  key?,\n  parent?\n): Observable<T> {\n  if (isObservable(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    throw new Error(\"Array object cannot be a root observable\");\n  }\n\n  const observableId = generateUniqueId();\n\n  observableInfoMap[observableId] = {\n    propObserverIdSetMap: {},\n    propGetterMap: {}\n  };\n\n  Object.defineProperty(obj, ID_KEY, {\n    value: observableId\n  });\n\n  for (const key of Object.keys(obj)) {\n    setProp(obj, key, obj[key]);\n  }\n\n  return obj as Observable<T>;\n}\n\n// Used to optimize observer-to-observer calls:\n// For nested notifyObservers calls, the observers will be called only once in the most outward notifyObservers call\nconst plannedObserverCalls = {};\nlet nextPlanIdx = 0;\nconst notifyObservers = function(observerIds: string[]) {\n  let planIdx = nextPlanIdx++;\n\n  let notify = true;\n  if (batchInfo.count > 0) {\n    notify = false;\n  }\n\n  for (const observerId of observerIds) {\n    if (plannedObserverCalls[observerId] != null) {\n      continue;\n    }\n\n    plannedObserverCalls[observerId] = planIdx;\n  }\n  for (const observerId of observerIds) {\n    const notifyInBatches = observerInfoMap[observerId].notifyInBatches;\n    if (\n      notify ||\n      notifyInBatches === true ||\n      (notifyInBatches && batchInfo.batchIdMap[notifyInBatches])\n    ) {\n      if (plannedObserverCalls[observerId] !== planIdx) {\n        continue;\n      }\n      callObserver(observerId);\n    } else {\n      if (batchInfo.observerIds.indexOf(observerId) === -1) {\n        batchInfo.observerIds.push(observerId);\n      }\n    }\n\n    delete plannedObserverCalls[observerId];\n  }\n};\n\nexport function notify<T extends Observable<any>, K extends keyof T>(\n  obj: T,\n  key: K\n) {\n  const propObserverIdSetMap =\n    observableInfoMap[obj.__observableId].propObserverIdSetMap[key as string];\n  notifyObservers(Object.keys(propObserverIdSetMap));\n}\n\nconst batchInfo: {\n  count: number;\n  observerIds: string[];\n  batchIdMap: Record<string, number>;\n} = {\n  count: 0,\n  observerIds: [],\n  batchIdMap: {}\n};\nexport const batch = function(fn: () => void, batchId?) {\n  batchStart(batchId);\n  fn();\n  batchEnd(batchId);\n};\n\nexport const batchStart = function(batchId?) {\n  batchInfo.count++;\n\n  if (!batchId) {\n    return;\n  }\n\n  if (batchInfo.batchIdMap[batchId]) {\n    batchInfo.batchIdMap[batchId]++;\n  } else {\n    batchInfo.batchIdMap[batchId] = 1;\n  }\n};\n\nexport const batchEnd = function(batchId?) {\n  if (batchInfo.count === 0) return;\n\n  batchInfo.count--;\n  if (batchId) {\n    batchInfo.batchIdMap[batchId]--;\n  }\n\n  if (batchInfo.count > 0) {\n    return;\n  }\n\n  let observerIds = batchInfo.observerIds;\n  batchInfo.observerIds = [];\n  batchInfo.batchIdMap = {};\n  notifyObservers(observerIds);\n};\n\nlet computationBatchIdx = 0;\nexport const computation = function<\n  T extends {},\n  P extends ComputationMap<T> = ComputationMap<T>\n>(propsObj: P, batch: boolean = true): [ComputationValues<P>, () => void] {\n  const batchId = \"computation-\" + computationBatchIdx++;\n\n  let obj = {};\n  const objKeys = Object.keys(propsObj);\n  for (const key of objKeys) {\n    obj[key] = null;\n  }\n\n  obj = observable(obj);\n\n  let observerIds = [] as string[];\n  let unsubscribed = false;\n  const unsubscribeFn = function() {\n    if (unsubscribed) return;\n    for (const observerId of observerIds) {\n      unobserve(observerId);\n    }\n    unsubscribed = true;\n  };\n\n  for (const key of objKeys) {\n    let init = true;\n    observerIds.push(\n      observe(function(pauseObserver) {\n        if (batch) {\n          batchStart(batchId);\n        }\n\n        obj[key] = propsObj[key](\n          obj,\n          observableInfoMap[obj[ID_KEY]].propGetterMap[key](),\n          key,\n          pauseObserver,\n          init\n        );\n\n        if (batch) {\n          batchEnd(batchId);\n        }\n      }, batchId)\n    );\n    init = false;\n  }\n\n  return [obj as any, unsubscribeFn];\n};\n\nexport const extract = function(obj, deep = true) {\n  let result = obj;\n\n  if (Array.isArray(obj)) {\n    result = [];\n    for (let value of obj) {\n      if (deep) {\n        value = extract(value, deep);\n      }\n      result.push(value);\n    }\n  } else if (isObservable(obj)) {\n    result = {};\n    for (const key of Object.keys(obj)) {\n      let value = obj[key];\n      if (deep) {\n        value = extract(value, deep);\n      }\n      result[key] = value;\n    }\n  }\n\n  return result;\n};\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}