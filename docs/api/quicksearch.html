<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_extras_extras.js.html":{"id":"lib_extras_extras.js.html","title":"Source: lib/extras/extras.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: lib/extras/extras.js /** * Extras, but useful stuff * * @namespace */ var extras = {} /** * Several included reducer examples */ extras.reducers = require('./reducers.js') module.exports = extras × Search results Close "},"lib_extras_reducers.js.html":{"id":"lib_extras_reducers.js.html","title":"Source: lib/extras/reducers.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: lib/extras/reducers.js var isObject = require('lodash/isObject') var reducers = {} /** * A basic reducer which just dispatches untyped actions * * @memberof extras */ reducers.basic = function (state, action) { /* if (action.payload != null &amp;&amp; isObject(action.payload)) { return action.payload } */ } module.exports = reducers × Search results Close "},"lib_handler_handler.js.html":{"id":"lib_handler_handler.js.html","title":"Source: lib/handler/handler.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: lib/handler/handler.js var u = require('./../util/util.js') /** * Handler class * TODO: Describe what this class is all about * * @class */ var Handler = function Handler () { handler.apply(this, arguments) } var handler = u.polymorphic() var handlerWithReducerArray = function handlerWithReducerArray (reducers) { /** * Is this handler enabled? * * @name _enabled * @memberof Handler * @private */ this._enabled = true /** * Unique ID of this handler * * @name _id * @memberof Handler * @private */ this._id = u.uniqueId() /** * Array of registered reducers * * @name _reducers * @memberof Handler * @private */ this._reducers = [] /** * Object of registered stores * * @name _stores * @memberof Handler * @private */ this._stores = {} if (!u.isArray(reducers)) { throw new Error('Argument given is not an array') } else { this.addReducer(reducers) } } handler.signature('array', handlerWithReducerArray) handler.signature('...', handlerWithReducerArray) handler.signature('function', function (func) { handlerWithReducerArray.call(this, [func]) }) handler.signature('', function () { handlerWithReducerArray.call(this, []) }) /** * Calls the registered reducers with the provided state and action * This is automatically started after a successfull dispatch on the Store * * @private * * @param {object} state * @param {object} action * * @return {object} state Returns the changed state */ Handler.prototype._handle = function _handle (state, action) { if (this._enabled === true) { u.forEach(this._reducers, function (item) { state = item.call(this, state, action) }) } return state } /** * Add reducer functions to the handler * * @function * * @param {array|function} reducer Array of reducers or single reducer function * @param {...function} reducers More reducers * * @return {Handler} this */ Handler.prototype.addReducer = u.polymorphic() var addReducer = Handler.prototype.addReducer var addReducerArray = function addReducerArray (reducers) { var self = this if (!u.isArray(reducers)) { throw new Error('Argument given is not an array') } u.forEach(reducers, function (reducer) { if (!u.isFunction(reducer)) { throw new Error('Item in array is not a function') } else { self._reducers.push(reducer) } }) return this } addReducer.signature('array', addReducerArray) addReducer.signature('...', addReducerArray) addReducer.signature('function', function (reducer) { return addReducerArray.call(this, [reducer]) }) /** * Connect one or multible stores to this handler * * @function * * @param {Store|array} store One store or array of stores * @param {boolean} fromStore Was this function called within a store * * @return {Handler} this */ Handler.prototype.addStore = u.polymorphic() var addStore = Handler.prototype.addStore var addStoreArray = function addStoreArray (stores, fromStore) { var self = this if (!u.isArray(stores)) { throw new Error('Argument given is not an array') } if (stores.length &gt; 0) { u.forEach(stores, function (store) { if (!u.isStore(store)) { throw new Error('Item in array given is not a store') } else { var id = store.getId() if (u.isString(id) &amp;&amp; id !== '') { self._stores[id] = store if (!u.isBoolean(fromStore) || fromStore !== true) { store.addHandler(self, true) } } } }) } return this } addStore.signature('array, boolean b=false', addStoreArray) addStore.signature('object, boolean b=false', function (store, fromStore) { return addStoreArray.call(this, [store], fromStore) }) /** * Disables this handler * * @return {Handler} this */ Handler.prototype.disable = function disable () { this._enabled = false return this } /** * Enables this handler * * @return {Handler} this */ Handler.prototype.enable = function enable () { this._enabled = true return this } /** * Get id of this handler * * @return {string} Unique ID of this handler */ Handler.prototype.getId = function getId () { return this._id } /** * Get registered reducers * * @private * * @return {array} reducers */ Handler.prototype._getReducers = function _getReducers () { return this._reducers } /** * Remove a store or all stores from this handler * * @function * * @param {integer|Store|boolean} store|fromStore * @param {boolean} fromStore Was this called within a store? * * @return {Handler} this */ Handler.prototype.removeStore = u.polymorphic() var removeStore = Handler.prototype.removeStore var removeStoreById = function removeStoreById (id, fromStore) { if (!u.isString(id) || id !== '') { throw new Error('Provided id is not a valid string') } else { if (this._stores[id] != null) { if (!u.isBoolean(fromStore) || fromStore !== true) { if (u.isStore(this._stores[id])) { this._stores[id].removeHandler(this.getId(), true) } } delete this._stores[id] } } return this } removeStore.signature('string, boolean b=false', removeStoreById) removeStore.signature('object, boolean b=false', function (store, fromStore) { if (!u.isStore(store)) { throw new Error('Argument of type object is not a store') } else { return removeStoreById.call(this, store.getId(), fromStore) } }) removeStore.signature('boolean a=false', function (fromStore) { var self = this u.forEach(this._stores, function (store, idx) { removeStoreById.call(self, idx, fromStore) }) return this }) /** * Stops this handler: it will be disabled and removed from all stores * * @return {Handler} this */ Handler.prototype.stop = function stop () { this.removeStore() this.disable() return this } module.exports = Handler × Search results Close "},"lib_namespace.js.html":{"id":"lib_namespace.js.html","title":"Source: lib/namespace.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: lib/namespace.js /** * alo Modul * @module alo */ var util = require('./../lib/util/util.js') /** * public object with access to the different constructors */ module.exports = { /** * Same as new Handler * @see Handler */ createHandler: util.createHandler, /** * Same as new Store * @see Store */ createStore: util.createStore, /** * Access to the util namespace * * @see util */ util: util, /** * Access to the handler constructor * * @see Handler */ Handler: require('./../lib/handler/handler.js'), /** * Access to the store constructor * * @see Store */ Store: require('./../lib/store/store.js'), /** * Access to the subscription constructor * * @see Subscription */ Subscription: require('./../lib/subscription/subscription.js') } × Search results Close "},"main_alo.full.js.html":{"id":"main_alo.full.js.html","title":"Source: main/alo.full.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: main/alo.full.js var alo = require('./../lib/namespace.js') var extras = require('./../lib/extras/extras.js') /** * Useful functions * * @memberof module:alo * * @see extras */ alo.extras = extras module.exports = alo × Search results Close "},"lib_store_store.js.html":{"id":"lib_store_store.js.html","title":"Source: lib/store/store.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: lib/store/store.js var u = require('./../util/util.js') /** * The core of Alo. A store is the central place for application state * * @class * * @param {Object} state - Optional object to set as a start state */ var Store = function AloStore (state) { if (!u.isObject(state)) { state = {} } /** * @private */ this._namespace = [] /** * @private */ this.protected = { id: u.uniqueId(), state: state, publicState: {}, handlers: {}, subscriptions: [] } this._synchronize() } Store.prototype.getId = function getId () { return this.protected.id } /** * Adds a handler object to the registered handlers * * @param {Handler} handler * * @return {Store} this */ Store.prototype.addHandler = function addHandler (handler, fromHandler) { if (u.isHandler(handler)) { var id = handler.getId() if (u.isString(id) &amp;&amp; id !== '') { if (!u.isBoolean(fromHandler) || fromHandler !== true) { handler.addStore(this, true) } this.protected.handlers[id] = handler } } return this } /** * Removes a handler from the currently registered handlers * {int|Handler} handler id or Handler * @return {Store} this */ Store.prototype.removeHandler = function removeHandler (arg1, fromHandler) { var id = null if (u.isString(arg1)) { id = arg1 } else if (u.isHandler(arg1)) { id = arg1.getId() } if (u.isString(id) &amp;&amp; id !== '') { if (!u.isBoolean(fromHandler) || fromHandler !== true) { this.protected.handlers[id].removeStore(this.getId(), true) } delete this.protected.handlers[id] } return this } /** * Registers one or multible reducers * * @function * * @param {array|...function} Array or variadic call of one or multible reducer functions * * @return {Handler} * @see Handler */ Store.prototype.addReducer = u.polymorphic() var addReducer = Store.prototype.addReducer var addReducerArray = function (reducer) { var handler = u.createHandler(reducer) this.addHandler(handler) return handler } addReducer.signature('array', addReducerArray) addReducer.signature('function', function (func) { var reducers = [func] return addReducerArray.call(this, reducers) }) addReducer.signature('...', function (rest) { return addReducerArray.call(this, rest) }) /** * Syncs the public state variable with the protected state * @private * @param no param :) */ Store.prototype._synchronize = function _synchronize () { this.protected.publicState = u.cloneDeep(this.protected.state) } Store.prototype._publish = function _publish (namespace, message) { var self = this self._synchronize() u.forEach(self.protected.subscriptions, function (subscription) { self._callSubscription(subscription, namespace, message) }) } Store.prototype._setState = function _setState (newState, namespace, stateParam) { var self = this if (!u.isString(namespace)) { if (typeof (stateParam) === 'undefined') { namespace.unshift('state') self._setState(newState, namespace, self.protected) } else { if (namespace.length &gt; 1) { var currentNamespace = namespace[0] if (stateParam[currentNamespace] == null) { stateParam[currentNamespace] = {} } namespace.shift() return self._setState(newState, namespace, stateParam[currentNamespace]) } else if (namespace.length === 1) { stateParam[namespace[0]] = newState } } } else { self.protected.state = newState } } Store.prototype._getStateByNamespace = function _getStateByNamespace (namespace, state) { var self = this if (typeof (state) === 'undefined') { state = self.protected.state } namespace = self._getPreparedNamespace(namespace) u.forEach(namespace, function (currentNamespace) { if (state[currentNamespace] == null) { state[currentNamespace] = {} } state = state[currentNamespace] }) return state } Store.prototype._getPreparedNamespace = function _getPreparedNamespace (namespace) { switch (typeof (namespace)) { case 'string': namespace = namespace.split('.') break case 'undefined': namespace = [] break } return namespace } Store.prototype._getExtendedNamespace = function _getExtendedNamespace (extNamespace) { var self = this var namespace = self._getNamespace() extNamespace = self._getPreparedNamespace(extNamespace) return namespace.concat(extNamespace) } Store.prototype._callSubscription = function _callSubscription (subscription, namespace, message) { var self = this if (subscription != null) { var state = self._getStateByNamespace(subscription.namespace) if (subscription.namespace != null) { namespace = self._getPreparedNamespace(namespace) if (namespace.length &gt; 0) { var inNamespace = namespace.every(function (namespaceItem, idx) { return (subscription.namespace[idx] == null || subscription.namespace[idx] === namespaceItem) }) if (inNamespace) { subscription.callbackFunction.call(null, u.cloneDeep(state), message) } } else { subscription.callbackFunction.call(null, u.cloneDeep(state), message) } } else { subscription.callbackFunction.call(null, u.cloneDeep(state), message) } } return self } Store.prototype._getDispatcher = function _getDispatcher (namespace) { var self = this return function (newState, message) { if (u.isObject(newState) &amp;&amp; newState != null) { self._setState(newState, u.cloneDeep(namespace)) u.forEach(self.protected.handlers, function (handler) { // TODO: State and action needs to be added here handler._handle() }) } self._publish(namespace, message) } } Store.prototype.yet = function yet (namespace) { namespace = this._getExtendedNamespace(namespace) return this._getStateByNamespace(namespace, this.protected.publicState) } Store.prototype._getNamespace = function _getNamespace () { return this._namespace } Store.prototype.subscribe = function subscribe (functionParam, namespace) { var self = this var subscription = { namespace: u.cloneDeep(self._getExtendedNamespace(namespace)) } var callbackFunction = null if (u.isStore(functionParam)) { callbackFunction = function () { functionParam.dispatch() } } else { callbackFunction = functionParam } subscription.callbackFunction = callbackFunction var idx = self.protected.subscriptions.push(subscription) idx-- var Subscription = require('./../subscription/subscription.js') return new Subscription(idx, self.protected, subscription.namespace) } Store.prototype.us = Store.prototype.unsubscribe = function unsubscribe (subscription) { this.protected.subscriptions[subscription.id] = null return this } /** * Dispatches new state */ Store.prototype.dispatch = function dispatch (functionParam, namespace) { var self = this namespace = self._getExtendedNamespace(namespace) var state = self._getStateByNamespace(namespace) state = u.cloneDeep(state) var dispatcher = self._getDispatcher(namespace) var handleSingleDispatch = function handleSingleDispatch (func) { if (u.isFunction(functionParam)) { switch (functionParam.length) { case 0: var functionResult = functionParam() if (functionResult != null) { dispatcher(functionResult) } break case 1: var functionResult = functionParam(state) if (functionResult != null) { dispatcher(functionResult) } break default: functionParam(state, dispatcher) break } } } switch (typeof (functionParam)) { case 'function': handleSingleDispatch(functionParam) break case 'object': if (u.isArray(functionParam)) { u.forEach(functionParam, function (functionParamItem) { handleSingleDispatch(functionParamItem) }) } break case 'string': dispatcher(null, functionParam) break default: dispatcher() } return this } module.exports = Store × Search results Close "},"lib_subscription_subscription.js.html":{"id":"lib_subscription_subscription.js.html","title":"Source: lib/subscription/subscription.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: lib/subscription/subscription.js var Store = require('./../store/store.js') /** * Subscription Constructor, is used in the Store Class to create Subscriptions to state * * @class * @extends {Store} * @see Store * @param {number} id * @param {Object} storeProtected * @param {string | Array} namespace */ var Subscription = function AloSubscription (id, storeProtected, namespace) { this._id = id this._namespace = this._getPreparedNamespace(namespace) this.protected = storeProtected } Subscription.prototype = Object.create(Store.prototype) Subscription.prototype.constructor = Subscription Subscription.prototype.remember = function remember () { this._callSubscription(this.protected.subscriptions[this._id]) return this } module.exports = Subscription × Search results Close "},"lib_util_util.js.html":{"id":"lib_util_util.js.html","title":"Source: lib/util/util.js","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Source: lib/util/util.js /** * Several utility functions / libs used by alo * * Some of this functions / libs might change over time: Please read the description of the specific function / lib. * * @namespace * */ var util = {} // Library functions // Lodash /** * Lodash cloneDeep, can be used * * @function */ util.cloneDeep = require('lodash/cloneDeep') /** * Lodash forEach, can be used * * @function */ util.forEach = require('lodash/forEach') /** * Lodash isFunction, can be used * * @function */ util.isFunction = require('lodash/isFunction') /** * Lodash isString, can be used * * @function */ util.isString = require('lodash/isString') /** * Lodash isObject, can be used * * @function */ util.isObject = require('lodash/isObject') /** * Lodash isArray, can be used * * @function */ util.isArray = require('lodash/isArray') /** * Lodash isBoolean, can be used * * @function */ util.isBoolean = require('lodash/isBoolean') /** * Lodash uniqueId, can be used * * @function */ util.uniqueId = require('lodash/uniqueId') var flyd = require('flyd') /** * Flyd stream: Might change! * * @function */ util.createStream = flyd.stream /** * Flyd stream: Might change! * * @function */ util.combineStream = flyd.combine /** * Flyd isStream: Might change! * * @function */ util.isStream = flyd.isStream /** * Flyd immediate: Might change! * * @function */ util.immediateStream = flyd.immediate /** * Flyd endsOn: Might change! * * @function */ util.streamEndsOn = flyd.endsOn /** * Flyd map: Might change! * * @function */ util.mapStream = flyd.map /** * Flyd on: Might change! * * @function */ util.streamOn = flyd.on /** * Flyd scan: Might change! * * @function */ util.scanStream = flyd.scan /** * Flyd merge: Might change! * * @function */ util.mergeStream = flyd.merge /** * Flyd transduce: Might change! * * @function */ util.transduceStream = flyd.transduce /** * Flyd curryN: Might change! * * @function */ util.curryN = flyd.curryN /** * Polymorphic helper: Might change! * * @function */ util.polymorphic = require('polymorphic') /** * Alo specific functions */ /** * Same as new Handler * @see Handler */ util.createHandler = function createHandler () { var Handler = require('./../handler/handler.js') var handler = Object.create(Handler.prototype) Handler.apply(handler, arguments) return handler } /** * Same as new Store * @see Store */ util.createStore = function createStore () { var Store = require('./../store/store.js') var store = Object.create(Store.prototype) Store.apply(store, arguments) return store } /** * Instanceof check for handlers * * @param {*} handler Argument to check if it is a handler * * @return {boolean} true of it is a handler, false in the other case */ util.isHandler = function isHandler (handler) { var Handler = require('./../handler/handler.js') return (handler instanceof Handler) } /** * Instanceof check for stores * * @param {*} store Argument to check if it is a store * * @return {boolean} true of it is a store, false in the other case */ util.isStore = function isStore (store) { var Store = require('./../store/store.js') return (store instanceof Store) } module.exports = util × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Modules Classes Handler Store Subscription Namespaces extras util × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Classes Classes Handler Store Subscription Namespaces extras util × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Namespaces Classes Handler Store Subscription Namespaces extras util × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Welcome to Alo × Search results Close "},"extras.html":{"id":"extras.html","title":"Namespace: extras","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Namespace: extras extras Extras, but useful stuff Source: lib/extras/extras.js, line 6 Members &lt;static&gt; reducers Several included reducer examples Source: lib/extras/extras.js, line 11 Methods &lt;static&gt; reducers.basic() A basic reducer which just dispatches untyped actions Source: lib/extras/reducers.js, line 10 × Search results Close "},"Handler.html":{"id":"Handler.html","title":"Class: Handler","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Class: Handler Handler new Handler() Handler class TODO: Describe what this class is all about Source: lib/handler/handler.js, line 9 Members &lt;private, static&gt; _enabled Is this handler enabled? Source: lib/handler/handler.js, line 14 &lt;private, static&gt; _id Unique ID of this handler Source: lib/handler/handler.js, line 23 &lt;private, static&gt; _reducers Array of registered reducers Source: lib/handler/handler.js, line 32 &lt;private, static&gt; _stores Object of registered stores Source: lib/handler/handler.js, line 41 Methods &lt;private&gt; _getReducers() Get registered reducers Source: lib/handler/handler.js, line 199 Returns: reducers Type array &lt;private&gt; _handle(state, action) Calls the registered reducers with the provided state and action This is automatically started after a successfull dispatch on the Store Parameters: Name Type Description state object action object Source: lib/handler/handler.js, line 77 Returns: state Returns the changed state Type object addReducer(reducer, reducers) Add reducer functions to the handler Parameters: Name Type Argument Description reducer array | function Array of reducers or single reducer function reducers function &lt;repeatable&gt; More reducers Source: lib/handler/handler.js, line 97 Returns: this Type Handler addStore(store, fromStore) Connect one or multible stores to this handler Parameters: Name Type Description store Store | array One store or array of stores fromStore boolean Was this function called within a store Source: lib/handler/handler.js, line 131 Returns: this Type Handler disable() Disables this handler Source: lib/handler/handler.js, line 166 Returns: this Type Handler enable() Enables this handler Source: lib/handler/handler.js, line 177 Returns: this Type Handler getId() Get id of this handler Source: lib/handler/handler.js, line 188 Returns: Unique ID of this handler Type string removeStore(store|fromStore, fromStore) Remove a store or all stores from this handler Parameters: Name Type Description store|fromStore integer | Store | boolean fromStore boolean Was this called within a store? Source: lib/handler/handler.js, line 213 Returns: this Type Handler stop() Stops this handler: it will be disabled and removed from all stores Source: lib/handler/handler.js, line 254 Returns: this Type Handler × Search results Close "},"module-alo.html":{"id":"module-alo.html","title":"Module: alo","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Module: alo alo Modul Source: lib/namespace.js, line 1 Members &lt;static&gt; alo.extras Useful functions Source: main/alo.full.js, line 12 See: extras &lt;static&gt; createHandler Same as new Handler Source: lib/namespace.js, line 16 See: Handler &lt;static&gt; createStore Same as new Store Source: lib/namespace.js, line 22 See: Store &lt;static&gt; Handler Access to the handler constructor Source: lib/namespace.js, line 36 See: Handler &lt;static&gt; Store Access to the store constructor Source: lib/namespace.js, line 43 See: Store &lt;static&gt; Subscription Access to the subscription constructor Source: lib/namespace.js, line 50 See: Subscription &lt;static&gt; util Access to the util namespace Source: lib/namespace.js, line 29 See: util × Search results Close "},"Store.html":{"id":"Store.html","title":"Class: Store","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Class: Store Store new Store(state) The core of Alo. A store is the central place for application state Parameters: Name Type Description state Object Optional object to set as a start state Source: lib/store/store.js, line 10 Members &lt;private&gt; _namespace Source: lib/store/store.js, line 18 &lt;private&gt; protected Source: lib/store/store.js, line 23 Methods &lt;private&gt; _synchronize(no) Syncs the public state variable with the protected state Parameters: Name Type Description no param :) Source: lib/store/store.js, line 113 addHandler(handler) Adds a handler object to the registered handlers Parameters: Name Type Description handler Handler Source: lib/store/store.js, line 45 Returns: this Type Store addReducer(Array) Registers one or multible reducers Parameters: Name Type Description Array array | function or variadic call of one or multible reducer functions Source: lib/store/store.js, line 92 See: Handler Returns: Type Handler dispatch() Dispatches new state Source: lib/store/store.js, line 257 removeHandler() Removes a handler from the currently registered handlers {int|Handler} handler id or Handler Source: lib/store/store.js, line 63 Returns: this Type Store × Search results Close "},"Subscription.html":{"id":"Subscription.html","title":"Class: Subscription","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Class: Subscription Subscription new Subscription(id, storeProtected, namespace) Subscription Constructor, is used in the Store Class to create Subscriptions to state Parameters: Name Type Description id number storeProtected Object namespace string | Array Source: lib/subscription/subscription.js, line 13 See: Store Extends Store Members &lt;private&gt; _namespace Inherited From: Store#_namespace Overrides: Store#_namespace Source: lib/store/store.js, line 18 &lt;private&gt; protected Inherited From: Store#protected Overrides: Store#protected Source: lib/store/store.js, line 23 Methods &lt;private&gt; _synchronize(no) Syncs the public state variable with the protected state Parameters: Name Type Description no param :) Inherited From: Store#_synchronize Source: lib/store/store.js, line 113 addHandler(handler) Adds a handler object to the registered handlers Parameters: Name Type Description handler Handler Inherited From: Store#addHandler Source: lib/store/store.js, line 45 Returns: this Type Store addReducer(Array) Registers one or multible reducers Parameters: Name Type Description Array array | function or variadic call of one or multible reducer functions Inherited From: Store#addReducer Source: lib/store/store.js, line 92 See: Handler Returns: Type Handler dispatch() Dispatches new state Inherited From: Store#dispatch Source: lib/store/store.js, line 257 removeHandler() Removes a handler from the currently registered handlers {int|Handler} handler id or Handler Inherited From: Store#removeHandler Source: lib/store/store.js, line 63 Returns: this Type Store × Search results Close "},"util.html":{"id":"util.html","title":"Namespace: util","body":" Alo Namespaces extrasutil Modules alo Classes HandlerStoreSubscription Namespace: util util Several utility functions / libs used by alo Some of this functions / libs might change over time: Please read the description of the specific function / lib. Source: lib/util/util.js, line 9 Methods &lt;static&gt; cloneDeep() Lodash cloneDeep, can be used Source: lib/util/util.js, line 18 &lt;static&gt; combineStream() Flyd stream: Might change! Source: lib/util/util.js, line 82 &lt;static&gt; createHandler() Same as new Handler Source: lib/util/util.js, line 162 See: Handler &lt;static&gt; createStore() Same as new Store Source: lib/util/util.js, line 173 See: Store &lt;static&gt; createStream() Flyd stream: Might change! Source: lib/util/util.js, line 75 &lt;static&gt; curryN() Flyd curryN: Might change! Source: lib/util/util.js, line 145 &lt;static&gt; forEach() Lodash forEach, can be used Source: lib/util/util.js, line 25 &lt;static&gt; immediateStream() Flyd immediate: Might change! Source: lib/util/util.js, line 96 &lt;static&gt; isArray() Lodash isArray, can be used Source: lib/util/util.js, line 53 &lt;static&gt; isBoolean() Lodash isBoolean, can be used Source: lib/util/util.js, line 60 &lt;static&gt; isFunction() Lodash isFunction, can be used Source: lib/util/util.js, line 32 &lt;static&gt; isHandler(handler) Instanceof check for handlers Parameters: Name Type Description handler * Argument to check if it is a handler Source: lib/util/util.js, line 187 Returns: true of it is a handler, false in the other case Type boolean &lt;static&gt; isObject() Lodash isObject, can be used Source: lib/util/util.js, line 46 &lt;static&gt; isStore(store) Instanceof check for stores Parameters: Name Type Description store * Argument to check if it is a store Source: lib/util/util.js, line 199 Returns: true of it is a store, false in the other case Type boolean &lt;static&gt; isStream() Flyd isStream: Might change! Source: lib/util/util.js, line 89 &lt;static&gt; isString() Lodash isString, can be used Source: lib/util/util.js, line 39 &lt;static&gt; mapStream() Flyd map: Might change! Source: lib/util/util.js, line 110 &lt;static&gt; mergeStream() Flyd merge: Might change! Source: lib/util/util.js, line 131 &lt;static&gt; polymorphic() Polymorphic helper: Might change! Source: lib/util/util.js, line 152 &lt;static&gt; scanStream() Flyd scan: Might change! Source: lib/util/util.js, line 124 &lt;static&gt; streamEndsOn() Flyd endsOn: Might change! Source: lib/util/util.js, line 103 &lt;static&gt; streamOn() Flyd on: Might change! Source: lib/util/util.js, line 117 &lt;static&gt; transduceStream() Flyd transduce: Might change! Source: lib/util/util.js, line 138 &lt;static&gt; uniqueId() Lodash uniqueId, can be used Source: lib/util/util.js, line 67 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
